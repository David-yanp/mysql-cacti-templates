#summary How to create new templates or graphs

*Note: this document is a work in progress, and is incomplete.*

= Introduction =

This document explains how to create Cacti templates simply and reliably.  For this example, we'll assume you are going to add a new set of graphs into the ss_get_by_ssh.php file.  This means you're going to write a command to SSH to a server and collect some data, parsing code to turn that into a list of named values to graph, and graphs to display the result.

This example will show a fairly complex set of graphs.  If you understand the example, you should be ready to create quite complex graphs yourself.  We're going to collect data from /proc/diskstats on Linux and graph it.

= Collecting and Parsing the Data =

Getting the data is quite simple.  You will simply going to SSH to the server we're graphing and `cat /proc/diskstats`.  Then you'll parse the result into name-value pairs.

Start by writing tests against sample files, before we write any code.  This is the single most important part of creating reliable graphing code.  Collect several samples of /proc/diskstats from different sources so you get a variety of cases.  For example, it's best to collect samples from different kernel versions or distributions.  Save these into files such as `t/samples/diskstats-001.txt` as test samples.

Next, write the tests.  Open up t/get_by_ssh.php and add is_deeply() calls to the bottom to test each sample.  You're going to test a function called `diskstats_parse()`.  (But don't write the function yet!)  The name of this function is important, as we'll see a bit later.  The naming convention is how the PHP script will find and execute the function.  It needs to be SOMETHING_parse, where SOMETHING is the command-line argument given to the script's `--type` option.  In this case, "diskstats" seems like a good name: the command-line will eventually be something like `php ss_get_by_ssh.php --type diskstats ....` which is reasonable.

Each call to the function will return information about one disk device, so you'll need to add a `--device` option to the PHP script eventually.  For right now, all you need to know is that the prototype of `diskstats_parse()` is an array and a string of text.  The array is command-line options, and the text is the contents of `/proc/diskstats`.  The call will look like this:

{{{
diskstats_parse( array('device' => 'hda1'), "<contents of /proc/diskstats....>" );
}}}

Refer to documentation as needed and hand-interpret the sample file, then write out the values you expect to be returned in the test.  This should be a name-value list with *meaningful names*.  This is quite important.  The names you choose here will be used in many different places, including as text on the graphs we'll eventually create.  Separate words with underscores and use all lowercase letters.  Choose a unique 4-letter uppercase prefix for the name.  For example,

{{{
is_deeply(
   diskstats_parse( array('device' => 'hda1'), file_get_contents('samples/diskstats-001.txt') ),
   array(
      'DISK_reads'              => '12043',
      'DISK_reads_merged'       => '387',
      'DISK_sectors_read'       => '300113',
      'DISK_time_spent_reading' => '6.472',
      'DISK_writes'             => '12737',
      'DISK_writes_merged'      => '21340',
      'DISK_sectors_written'    => '272616',
      'DISK_time_spent_writing' => '22.36',
      'DISK_io_ops_in_progress' => '0',
      'DISK_io_time'            => '12.368',
      'DISK_io_time_weighted'   => '28.832'
   ),
   'samples/diskstats-001.txt'
);
}}}

Once you have the test written, execute the test file and ensure the test fails!  If it doesn't fail, you have no reliable indicator that a passing test really means success:

{{{
mysql-cacti-templates/t$ php get_by_ssh.php
}}}

You should see a fatal error that the function `diskstats_parse()` doesn't exist.  Great.  Now it's time to write it.  Open up `scripts/ss_get_by_ssh.php`.  Go all the way to the bottom of the file.  Scroll upwards three functions.  Those three functions should be the three magically named functions for some other parsing process.  Take a look at them and use them as a reference for writing your own function.  Copy the block comment header, and start your own function.  It should look like this:

{{{
function diskstats_parse ( $options, $output ) {
   $result = array();
   # write some code here
   return $result;
}
}}}

The returned value should be the array that you're testing for.  Write until your test passes, and then write similar tests for the other two sample files.  Now you're done with the parsing code!

= Writing the Command Line =

= Old Content =

*Everything below here is old content, to be merged into the new content above.*

You can base your new graph off the existing ones.  For the MySQL graphs, everything you need is in definitions/mysql_definitions.pl.

This file is read in as a big variable by tools/make_template.pl.  It consists of the following sections, which will be combined to form a template for Cacti:

  * name and hash -- properties for the template.
  * version -- a hash and string to indicate the template version.
  * graphs -- a graph is a data template plus a collection of graph items.
  * inputs -- this basically defines how the command-line script is called.

The version will really be turned into a GPRINT preset, which you can then view from the Cacti interface by going to Graph Management, then GPRINT Presets.  You will then see a GPRINT named something like "X MySQL Server Version t1.1.4:s1.1.4", which indicates that the installed version of the template was generated with version 1.1.4 of the template definition against version 1.1.4 of the related data-gathering script.

Optionally, you can define these:

  * gprints -- Custom sprintf formats.  You don't need to modify these.
  * rras -- these are just some custome RRA definitions so you can keep more than the usual amount of data.
  * cdefs -- these are custom CDEF sections, which generally don't need to be modified.

If you don't define these, built-in defaults are used.  They're kept in the tools/make-template.pl script.

In addition, there's a magical word `MAGIC_VARS_DEFINITIONS` that you can put into the script file that'll be read with the --script option.  This will cause the entire following paragraph to be read in and included into the definition too.  This lets you specify a short_names array/hash that shortens the command-line output to avoid problems with Cacti's limited built-in buffer sizes.

The hardest part is keeping track of how all these things are related to each other.  I have simplified the relationships significantly: one data template per each graph template, etc.

A graph will really be input to Cacti as a graph template and a data template.

The graph item in the definitions/mysql_definitions.pl file has the following properties:

  * base_value -- either 1024 or 1000 depending on whether the unit is an amount of data or not.  (Rule: don't mix things with different units on a single graph.  If you do, you get meaningless crap most of the time.)
  * name -- the name of the graph.  Keep it short.
  * hash -- the Cacti hash.  See CactiHashes.
  * dt -- the data template.
    * hash.
    * Name of the data input.  This is the name of an item in the inputs section at the top level.
    * items to get from the data input.  These are a hash reference.  The key is the name of the value to get from the data input (e.g. pool_size for the InnoDB Buffer Pool graph template).  The hash reference's children are the:
      * type: 1 => GAUGE, 2 => COUNTER (increasing, with overflow checks), 3 => DERIVE (no overflow checks).  Prefer DERIVE with a min value of 0 over COUNTER (see issue 41).
      * hash.
  * items -- the array of graph items (lines and such).  Each item is a hash.  There are these properties:
    * color -- a hex color code.  Try looking at http://www.colourlovers.com/palettes/top
    * item -- the name of the data item to graph.
    * type -- the RRD type, such as LINE1 or AREA or STACK.  Text items will automatically be added for each thing that is drawn on the graph.
    * task -- a hash.
    * hashes -- an array of hashes.  These are used for the items.  Depending on how many hashes are in the array, the graph will get varying bits of text below the picture.  The texts are Cur: Avg: Max: and you'll get them in that order, as many as you specify.  So if you only specify one hash, you'll just get Cur: on the graph.
    * cdef -- the optional name of a CDEF.  'Negate' is going to be the most frequent one you'll see.  This flips something across the Y axis.

The basic steps I use when developing templates are as follows.

  * Pick some new things to graph.  For example, let's say I want to graph Handler statistics.
  * Open scripts/ss_get_mysql_stats.php and add the new variables.  See r171 for an example of what to change.
  * Open definitions/mysql_definitions.pl and copy/paste a graph's definition; add it to the end of the existing ones.
  * Go through and edit the names, colors, data types, etc in the copy/pasted graph.
  * Run tools/unique-hashes.pl definitions/mysql_definitions.pl and save the output over the existing definitions/mysql_definitions.pl to make sure all the hashes are unique.
  * Open a terminal and go to /var/www/cacti/scripts.  'cat' the edited scripts/ss_get_mysql_stats.php file over the top of the existing one.
  * Run tools/make-template.pl --script scripts/ss_get_mysql_stats.php definitions/mysql_definitions.pl and save the output in ~/mysql-definitions.xml
  * Run "mysql cacti < ~/cacti.sql" to initialize the database.
  * Open the web browser, import the templates into Cacti, edit the Localhost device to be an "X MySQL Server", and add/create graphs.  Wait for data to be gathered.
  * Go to /var/www/cacti/scripts and run, for example, `php ss_get_mysql_stats.php --host localhost --items dn,ds,dw` and make sure you get some data.