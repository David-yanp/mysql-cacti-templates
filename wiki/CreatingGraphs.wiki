#summary How to create new templates or graphs

*Note: this document is a work in progress, and is incomplete.*

= Introduction =

This document explains how to create Cacti templates simply and reliably.  For this example, we'll assume you are going to add a new set of graphs into the ss_get_by_ssh.php file.  This means you're going to write a command to SSH to a server and collect some data, parsing code to turn that into a list of named values to graph, and graphs to display the result.

This example will show a fairly complex set of graphs.  If you understand the example, you should be ready to create quite complex graphs yourself.  We're going to collect data from /proc/diskstats on Linux and graph it.

= Collecting and Parsing the Data =

Getting the data is quite simple.  You will simply going to SSH to the server we're graphing and `cat /proc/diskstats`.  Then you'll parse the result into name-value pairs.

Start by writing tests against sample files, before we write any code.  This is the single most important part of creating reliable graphing code.  Collect several samples of /proc/diskstats from different sources so you get a variety of cases.  For example, it's best to collect samples from different kernel versions or distributions.  Save these into files such as `t/samples/diskstats-001.txt` as test samples.

Next, write the tests.  Open up t/get_by_ssh.php and add is_deeply() calls to the bottom to test each sample.  You're going to test a function called `diskstats_parse()`.  (But don't write the function yet!)  The name of this function is important, as we'll see a bit later.  The naming convention is how the PHP script will find and execute the function.  It needs to be SOMETHING_parse, where SOMETHING is the command-line argument given to the script's `--type` option.  In this case, "diskstats" seems like a good name: the command-line will eventually be something like `php ss_get_by_ssh.php --type diskstats ....` which is reasonable.

Each call to the function will return information about one disk device, so you'll need to add a `--device` option to the PHP script eventually.  For right now, all you need to know is that the prototype of `diskstats_parse()` is an array and a string of text.  The array is command-line options, and the text is the contents of `/proc/diskstats`.  The call will look like this:

{{{
diskstats_parse( array('device' => 'hda1'), "<contents of /proc/diskstats....>" );
}}}

Refer to documentation as needed and hand-interpret the sample file, then write out the values you expect to be returned in the test.  This should be a name-value list with *meaningful names*.  This is quite important.  The names you choose here will be used in many different places, including as text on the graphs we'll eventually create.  Separate words with underscores and use all lowercase letters.  Choose a unique 4-letter uppercase prefix for the name.  For example,

{{{
is_deeply(
   diskstats_parse( array('device' => 'hda1'), file_get_contents('samples/diskstats-001.txt') ),
   array(
      'DISK_reads'              => '12043',
      'DISK_reads_merged'       => '387',
      'DISK_sectors_read'       => '300113',
      'DISK_time_spent_reading' => '6.472',
      'DISK_writes'             => '12737',
      'DISK_writes_merged'      => '21340',
      'DISK_sectors_written'    => '272616',
      'DISK_time_spent_writing' => '22.36',
      'DISK_io_ops_in_progress' => '0',
      'DISK_io_time'            => '12.368',
      'DISK_io_time_weighted'   => '28.832'
   ),
   'samples/diskstats-001.txt'
);
}}}

Once you have the test written, execute the test file and ensure the test fails!  If it doesn't fail, you have no reliable indicator that a passing test really means success:

{{{
mysql-cacti-templates/t$ php get_by_ssh.php
}}}

You should see a fatal error that the function `diskstats_parse()` doesn't exist.  Great.  Now it's time to write it.  Open up `scripts/ss_get_by_ssh.php`.  Go all the way to the bottom of the file.  Scroll upwards three functions.  Those three functions should be the three magically named functions for some other parsing process.  Take a look at them and use them as a reference for writing your own function.  Copy the block comment header (don't worry much about its contents for right now), and start your own function.  It should look like this:

{{{
function diskstats_parse ( $options, $output ) {
   $result = array();
   # write some code here
   return $result;
}
}}}

The returned value should be the array that you're testing for.  Write until your test passes, and then write similar tests for the other two sample files.  Now you're done with the parsing code!

= Writing the Command Line =

Once you've gotten this far, you've collected sample data, and written well-tested code to parse it.  This code lives in a function called `diskstats_parse()`, which follows a specific naming convention.  You need two more functions that follow the same naming convention, and the command-line option that'll cause these functions to be executed.

The first function specifies a cache filename.  Caching is an efficiency feature that helps work around a flaw in Cacti's design.  The filename needs to be unique for every different host and device you want to graph, so we're going to need to include the --host and the --device command-line options in the filename.  The second function creates the command line that'll gather the data from /proc/diskstats over SSH.  The functions can be quite simple.

{{{
function diskstats_cachefile ( $options ) {
   $sanitized_host
       = str_replace(array(":", "/"), array("", "_"), $options['host']);
   $sanitized_dev
       = str_replace(array(":", "/"), array("", "_"), $options['device']);
   return "${sanitized_host}_diskstats_${sanitized_dev}";
}

function diskstats_cmdline ( $options ) {
   return "cat /proc/diskstats";
}
}}}

Now you need to let the user know how to execute these functions.  This is done via the `--type` command-line option to the PHP script.  The argument to this option can be free-form text, so all you need to do is add the text to the `--help` output.  Here's a diff to show what to change:

{{{
@@ -197,7 +198,7 @@
    --server    The server (DNS name or IP address) from which to fetch the
                desired data after SSHing.  Default is 'localhost' for HTTP stats
                and --host for memcached stats.
-   --type      One of apache, nginx, proc_stat, w, memory, memcached
+   --type      One of apache, nginx, proc_stat, w, memory, memcached, diskstats
                (more are TODO)
    --url       The url, such as /server-status, where server status lives
    --use-ssh   Whether to connect via SSH to gather info (default yes).
}}}

Hopefully that's clear.

There is one final detail, which is necessary because this is a rather advanced graphing task: we need to add a `--device` command-line option so the PHP code can figure out which disk device the user is interested in graphing.  This should be added in two places: a) the command-line `--help` output we just saw, and b) in the `validate_options()` function.  Here's another diff:

{{{
@@ -160,7 +160,7 @@
 function validate_options($options) {
    debug($options);
    $opts = array('host', 'port', 'items', 'nocache', 'type', 'url', 'http-user',
-                 'file', 'http-password', 'server', 'port2', 'use-ssh');
+                 'file', 'http-password', 'server', 'port2', 'use-ssh', 'device');
    # Required command-line options
    foreach ( array('host', 'items', 'type') as $option ) {
       if ( !isset($options[$option]) || !$options[$option] ) {
}}}

Now you can specify `--device sda1` or similar, and the code can access that through `$options['device']`, as you've seen in the examples above.

= Specifying a Short-Name Mapping =

You already created long, descriptive names for the data values you're going to graph.  Unfortunately, due to another Cacti limitation, these names can't be used safely everywhere.  In most Cacti templates, the script returns a key:value string to Cacti, like this:

{{{
Name_of_data_value:1234 Name_of_another_data_value:5678
}}}

That's nice, but when you get a few dozen values back from a single call, Cacti starts losing data because it has a fixed-length buffer it reads these things into.  And due to yet another Cacti design flaw, for efficiency it really is important to return all the values at once.  So we need short names, and a mapping between the long and the short names.  It would be a hassle to keep track of all this, but the system you're working in centralizes that all and makes it much easier for you.

The mapping is defined in an array in the PHP script, which -- and this is important -- is one big paragraph of text (no empty lines) preceded by the magic word MAGIC_VARS_DEFINITIONS.  You need to append your data variables to this array and give each name a unique abbreviation.  For example,

{{{
   # Define the variables to output.  I use shortened variable names so maybe
   # it'll all fit in 1024 bytes for Cactid and Spine's benefit.  This list must
   # come right after the word MAGIC_VARS_DEFINITIONS.  The Perl script parses
   # it and uses it as a Perl variable.
   $keys = array(
      # ............. <previous entries omitted> ............
      # Diskstats stuff
      'DISK_reads'              => 'bj',
      'DISK_reads_merged'       => 'bk',
      'DISK_sectors_read'       => 'bl',
      'DISK_time_spent_reading' => 'bm',
      'DISK_writes'             => 'bn',
      'DISK_writes_merged'      => 'bo',
      'DISK_sectors_written'    => 'bp',
      'DISK_time_spent_writing' => 'bq',
      'DISK_io_ops_in_progress' => 'br',
      'DISK_io_time'            => 'bs',
      'DISK_io_time_weighted'   => 'bt',
   );
}}}

The convention is two-letter abbreviations, beginning at a0, a1, and so on.  Just append to the list and continue the convention.  Separate your entries with a short comment, such as `Diskstats stuff` as shown above.

Now you can see why the uppercase DISK identifier chosen earlier (during the test phase) is necessary.  This makes the names unique.  Otherwise you might end up with two items in this array with the key 'writes' and you'd have a problem.

The short names go into the `--items` command-line argument.  This argument can take any combination of short names.  Now that you know what your short names are going to be, go back to the comment header right above the `diskstats_cachefile()` function, and write a sample command-line users can use to test the functionality you're creating, such as:

{{{
# ============================================================================
# Get and parse stats from /proc/diskstats
# You can test it like this, as root:
# su - cacti -c 'env -i php /var/www/cacti/scripts/ss_get_by_ssh.php --type diskstats --host 127.0.0.1 --items bj,bk,bl,bm,bn,bo,bp'
# ============================================================================
function diskstats_cachefile ( $options ) {
}}}

Notice that the `--items` argument is simply a comma-separated list of the short names you defined in the mapping array.

= Write Another Test =

At this point, you're finished with everything PHP'ish, except for one last thing: write another test case.  Write your final test case to test the integration of all the code you've written, and ensure that it all works right together.  Look in the test file for tests against the `ss_get_by_ssh()` function, and emulate that.  For example,

{{{
is(
   ss_get_by_ssh( array(
      'file'    => 'samples/diskstats-001.txt',
      'type'    => 'diskstats',
      'host'    => 'localhost',
      'items'   => 'bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt',
      'device'  => 'hda1'
   )),
   'bj:12043 bk:387 bl:300113 bm:6.472 bn:12737 bo:21340 bp:272616 bq:22.36 '
      . 'br:0 bs:12.368 bt:28.832',
   'main(samples/diskstats-001.txt)'
);
}}}

Now you're really done, and you can go on to defining the graphs.

= How the Graph System Works =

Cacti's templating system is really difficult to understand and work with.  It uses cryptic values, has redundant data all over the place (so you can't tell what's meaningful and what's just accidentally duplicated data), and uses randomly generated hashes as unique identifiers for things.  The typical Cacti template is defined within Cacti and then exported, which results in an unholy mess for anyone who tries to import that template.  All sorts of nastiness results.  And to top it off, creating nice consistent templates is tedious.  You could easily spend several days doing it, one click at a time.  I know, because before I wrote this automatic templating system, I spent several weeks trying to whip someone else's templates into a shape that I considered usable and wouldn't sabotage my Cacti installation.

All that is behind us now.  The system you're about to see might look a little cryptic, but that's because it is a highly compressed definition of the template system that Cacti uses.  This system cuts out redundancy, and follows a certain set of conventions to eliminate a lot of work (and a lot of errors).  Without this, it would be just as cryptic -- but it would be an order of magnitude bigger and harder to understand.

In this system, there is a fairly simple relationship between the moving parts in the system.  If you're familiar with Cacti, the following might help you understand:

  # An input is defined only once, instead of being defined over and over for every different graph.  This means that all the graphs for a related set of data draw their data from a common command.  The input is defined by a command-line that executes it, command-line arguments it accepts, and values it outputs.
  # Each graph is associated with one graph template.
  # Each graph template has a corresponding data template, which has exactly the inputs and outputs that the graph needs, no more, no less.  Data templates are not shared across several graph templates or vice versa; there is a strict one-to-one relationship.
  # Each RRD file definition maps exactly to one graph template and therefore to one data template, again in a one-to-one relationship.
  # The above one-to-one relationships prevent a lot of duplicated data being polled, retrieved, and stored in RRD files (which can get pretty big).
  # The graph templates, data templates, and RRD definitions are named the same way, but with a distinguishing suffix automatically added by the template generation tools.  This makes it easy to know what you're looking at!
  # The random hash identifiers are defined once and only once in the system, and are hard-coded into the definition file.  They never change, and that makes a lot of things work better.  Hard-coding removes the randomness and eliminates chaos.  The hashes are written in an abstract form in the definition file, to eliminate problems such as version dependencies (which typically prevent templates exported from a new version of Cacti being imported on an older version).

The summary of the above is "don't repeat yourself."  Cacti repeats itself a lot; this template system cuts all that out and simplifies things by creating a one-to-one-to-one relationship from the data collection all the way through to the graph definition.

Now that you know this, you're probably interested to learn about the definition file!

= Structure of the Definition File =

The definition file is basically one big Perl variable containing nested data structures.  It could have been YAML or JSON or XML or any of a number of other things. But it's not, it's Perl.

The relationship amongst the various types of data looks like this:

  # There is one top-level template.
  # The template contains some properties such as name and version.
  # The template contains two major sections: graphs and inputs.
    # The graph section is an array of graph template definitions.  Because of the one-to-one-to-one relationship amongst them, each graph template definition implicitly defines a corresponding data template and an RRD file definition.
    # The input section is an array of input definitions.  Each one defines the data that flows between the PHP script you wrote above, and the graph templates.

I'll explain more later, as I go through the steps of creating a new set of graphs from the data we're newly able to collect.

Before we go on, though, you need to understand about hashes.  If you open up the definition file, you'll see some things that look like this:

{{{
         items => [
            {  item   => 'STAT_interrupts',
               color  => 'BF4E15',
               task   => 'hash_09_VER_e2a72b5aa0b06ad05dcd368ae0a131cf',
               type   => 'AREA',
               hashes => [
                  'hash_10_VER_3eae0c8f769939bb30c407d4edcee0c0',
                  'hash_10_VER_25aaadab40c1c8e12c45ce61693099b7',
                  'hash_10_VER_43f90f7f26a7c6b3ca41c7219afaa50c',
                  'hash_10_VER_df9555d08c88c6c0336fe37ffe2ad74a'
               ],
            },
         ],
      },
}}}

Those are hashes.  You're going to have to create unique hashes so Cacti doesn't get all confused.  You're going to need a lot of them, too!  Don't worry about it.  Just follow these simple steps and you'll be fine:

  # Always create your template definitions by copying and pasting whatever you're working on.  If you're creating a new input, copy and paste an old one.
  # Always copy and paste downwards in the file.  Never take something from the file and copy/paste it higher up in the file.

Copying and pasting will create duplicate hashes.  It doesn't matter.  There is a tool to detect these and randomly generate new ones that aren't duplicates.  This works great, as long as you don't copy/paste higher in the file.  If you do that, the pre-existing hashes will get overwritten with newer ones, which is bad.  Later I'll tell you to check for this, just in case.

= Defining an Input =

The first step is to define your input.  You created a whole new group of data, which you can get with `--type diskstats`.  Create a new input for that.  Let's copy/paste the input called "Get Proc Stats".  Copy the whole thing:

{{{
      'Get Proc Stats' => {
         type_id      => 1,
         hash         => 'hash_03_VER_b8d0468c0737dcd0863f2a181484f878',
         input_string => '<path_php_binary> -q <path_cacti>/scripts/ss_get_by_ssh.php '
                       . '--host <hostname> --type proc_stat --items <items>',
         inputs => [
            {  allow_nulls => '',
               hash        => 'hash_07_VER_509a24f84c924e9252be9a82c6674a6f',
               name        => 'hostname'
            },
         ],
         outputs => {
            STAT_interrupts       => 'hash_07_VER_cf50d22f8b5814fbb9e42d1b46612679',
            STAT_context_switches => 'hash_07_VER_49aa057a3935a96fb25fb511b16a75fa',
            STAT_forks            => 'hash_07_VER_d5e03c6e39717cc6a58e85e5f25608c6',
            STAT_CPU_user         => 'hash_07_VER_edfd4ac62e1e43ec35b3f5dc10ae2510',
            STAT_CPU_nice         => 'hash_07_VER_474ae20e35b85ca08645c018bd4c29c4',
            STAT_CPU_system       => 'hash_07_VER_89c1f51e8cbf6df135e4446e9c656e9b',
            STAT_CPU_idle         => 'hash_07_VER_f8ad00b68144973373281261a5100656',
            STAT_CPU_iowait       => 'hash_07_VER_e2d5a3ef480bb8ed8546fe48c3496717',
            STAT_CPU_irq          => 'hash_07_VER_a8ff7438a031f05bd223e5a016d443b2',
            STAT_CPU_softirq      => 'hash_07_VER_b7055f7e8e745ab6c0c7bbd85f7aff03',
            STAT_CPU_steal        => 'hash_07_VER_5686b4b2d255e674f46932ae60da92af',
            STAT_CPU_guest        => 'hash_07_VER_367fbfbb15a0bbd73fae5366d02e0c9b',
         },
      },
}}}

What does all that mean?  The name of the input is going to be called "Get Proc Stats".  It is of type 1, which is a PHP script.  It has a hash -- don't worry about that, but that's its unique identifier.  It has an input_string, which is really its command-line.  You can see some special things in angle-brackets, which is Cacti's replacement variable notation.

Next it has inputs.  (I know, it's confusing).  There is only one input, the hostname.  This is a placeholder for Cacti to insert the hostname into the script's command-line arguments when it executes the PHP.  If you're wondering what gets put into the `<items>` argument placeholder in the input_string, that's taken care of automatically by the template generation system.

Finally, the input has outputs.  (Yes, I know...)  These are the values that the PHP script will return when you call it.  However, for sanity, they are mentioned here in their long form.  As I said before, the short-to-long mapping is defined only once, in the PHP file.  Everywhere else you will use the long form of the names, and the template generation system will take care of translating that to the short form where needed.

You need to copy and paste the text, and just update it to make a new input definition.  You'll end up with something like this:

{{{
      'Get Disk Stats' => {
         type_id      => 1,
         hash         => 'hash_03_VER_da6fa9ee8283a483d4dea777fd69c629',
         input_string => '<path_php_binary> -q <path_cacti>/scripts/ss_get_by_ssh.php '
                       . '--host <hostname> --type diskstats --items <items> '
                       . '--device <device>',
         inputs => [
            {  allow_nulls => '',
               hash        => 'hash_07_VER_280cd9c759c52b2477b972334210f920',
               name        => 'hostname'
            },
            {  allow_nulls => '',
               hash        => 'hash_07_VER_e89872554729dcd0695528adec190dd2',
               name        => 'device'
            },
         ],
         outputs => {
            DISK_reads              => 'hash_07_VER_00e4dd20a4e29c673a4471b2ee173ac9',
            DISK_reads_merged       => 'hash_07_VER_8af205c19a7439e83cee53059096b8e3',
            DISK_sectors_read       => 'hash_07_VER_9c5a554f4d62343e5aaaf9f0d784ada0',
            DISK_time_spent_reading => 'hash_07_VER_e8fd959febe8cdd5b20b8282ba340f19',
            DISK_writes             => 'hash_07_VER_1384e83ff216c0377a5f213f9a88c6fa',
            DISK_writes_merged      => 'hash_07_VER_c9cb7f45fa6ad943c377efb3ba2e661d',
            DISK_sectors_written    => 'hash_07_VER_43f100a2f54d5b18c3cdc5e8b8a02293',
            DISK_time_spent_writing => 'hash_07_VER_e1886d79cfa3c526c899de03db6e07ee',
            DISK_io_time            => 'hash_07_VER_cad0f7e9d765ba4e9341de72c0366575',
            DISK_io_time_weighted   => 'hash_07_VER_d7ebd195f6d9048b8e1e84114e8a0b6d',
         },
      },
}}}

That should look familiar to you from the work you've done already.  The name is "Get Disk Stats".  The outputs are what you chose in your first test case.  The only thing really special here is that you need to add a command-line option for `--device`, because again, disk statistics have to know what device they're graphing.

Although I've shown newly generated hashes here, don't worry about it.  Copy/paste the hashes from the other input definition.  As long as you paste *below*, generating new hashes is easy.

= Old Content =

*Everything below here is old content, to be merged into the new content above.*

You can base your new graph off the existing ones.  For the MySQL graphs, everything you need is in definitions/mysql_definitions.pl.

This file is read in as a big variable by tools/make_template.pl.  It consists of the following sections, which will be combined to form a template for Cacti:

  * name and hash -- properties for the template.
  * version -- a hash and string to indicate the template version.
  * graphs -- a graph is a data template plus a collection of graph items.
  * inputs -- this basically defines how the command-line script is called.

The version will really be turned into a GPRINT preset, which you can then view from the Cacti interface by going to Graph Management, then GPRINT Presets.  You will then see a GPRINT named something like "X MySQL Server Version t1.1.4:s1.1.4", which indicates that the installed version of the template was generated with version 1.1.4 of the template definition against version 1.1.4 of the related data-gathering script.

Optionally, you can define these:

  * gprints -- Custom sprintf formats.  You don't need to modify these.
  * rras -- these are just some custome RRA definitions so you can keep more than the usual amount of data.
  * cdefs -- these are custom CDEF sections, which generally don't need to be modified.

If you don't define these, built-in defaults are used.  They're kept in the tools/make-template.pl script.

In addition, there's a magical word `MAGIC_VARS_DEFINITIONS` that you can put into the script file that'll be read with the --script option.  This will cause the entire following paragraph to be read in and included into the definition too.  This lets you specify a short_names array/hash that shortens the command-line output to avoid problems with Cacti's limited built-in buffer sizes.

The hardest part is keeping track of how all these things are related to each other.  I have simplified the relationships significantly: one data template per each graph template, etc.

A graph will really be input to Cacti as a graph template and a data template.

The graph item in the definitions/mysql_definitions.pl file has the following properties:

  * base_value -- either 1024 or 1000 depending on whether the unit is an amount of data or not.  (Rule: don't mix things with different units on a single graph.  If you do, you get meaningless crap most of the time.)
  * name -- the name of the graph.  Keep it short.
  * hash -- the Cacti hash.  See CactiHashes.
  * dt -- the data template.
    * hash.
    * Name of the data input.  This is the name of an item in the inputs section at the top level.
    * items to get from the data input.  These are a hash reference.  The key is the name of the value to get from the data input (e.g. pool_size for the InnoDB Buffer Pool graph template).  The hash reference's children are the:
      * type: 1 => GAUGE, 2 => COUNTER (increasing, with overflow checks), 3 => DERIVE (no overflow checks).  Prefer DERIVE with a min value of 0 over COUNTER (see issue 41).
      * hash.
  * items -- the array of graph items (lines and such).  Each item is a hash.  There are these properties:
    * color -- a hex color code.  Try looking at http://www.colourlovers.com/palettes/top
    * item -- the name of the data item to graph.
    * type -- the RRD type, such as LINE1 or AREA or STACK.  Text items will automatically be added for each thing that is drawn on the graph.
    * task -- a hash.
    * hashes -- an array of hashes.  These are used for the items.  Depending on how many hashes are in the array, the graph will get varying bits of text below the picture.  The texts are Cur: Avg: Max: and you'll get them in that order, as many as you specify.  So if you only specify one hash, you'll just get Cur: on the graph.
    * cdef -- the optional name of a CDEF.  'Negate' is going to be the most frequent one you'll see.  This flips something across the Y axis.

The basic steps I use when developing templates are as follows.

  * Pick some new things to graph.  For example, let's say I want to graph Handler statistics.
  * Open scripts/ss_get_mysql_stats.php and add the new variables.  See r171 for an example of what to change.
  * Open definitions/mysql_definitions.pl and copy/paste a graph's definition; add it to the end of the existing ones.
  * Go through and edit the names, colors, data types, etc in the copy/pasted graph.
  * Run tools/unique-hashes.pl definitions/mysql_definitions.pl and save the output over the existing definitions/mysql_definitions.pl to make sure all the hashes are unique.
  * Open a terminal and go to /var/www/cacti/scripts.  'cat' the edited scripts/ss_get_mysql_stats.php file over the top of the existing one.
  * Run tools/make-template.pl --script scripts/ss_get_mysql_stats.php definitions/mysql_definitions.pl and save the output in ~/mysql-definitions.xml
  * Run "mysql cacti < ~/cacti.sql" to initialize the database.
  * Open the web browser, import the templates into Cacti, edit the Localhost device to be an "X MySQL Server", and add/create graphs.  Wait for data to be gathered.
  * Go to /var/www/cacti/scripts and run, for example, `php ss_get_mysql_stats.php --host localhost --items dn,ds,dw` and make sure you get some data.